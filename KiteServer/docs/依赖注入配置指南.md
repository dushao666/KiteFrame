# 依赖注入配置指南

## 概述

KiteServer 项目采用统一的依赖注入配置方式，所有应用层服务都在 `Application/DependencyInjection` 目录下统一管理，避免在 `ProgramExtensions.cs` 中逐个注册服务。

## 配置结构

```
Application/DependencyInjection/
├── ApplicationServiceExtensions.cs    # 应用层服务扩展（主要配置文件）
└── MapsterConfiguration.cs           # Mapster 对象映射配置
```

## 核心配置文件

### ApplicationServiceExtensions.cs

这是应用层服务的统一配置入口：

```csharp
/// <summary>
/// 应用层服务扩展
/// </summary>
public static class ApplicationServiceExtensions
{
    /// <summary>
    /// 添加应用层服务
    /// </summary>
    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        // 添加查询服务
        services.AddQueryServices();
        
        // 其他服务配置...
        
        return services;
    }
    
    /// <summary>
    /// 添加查询服务
    /// </summary>
    private static IServiceCollection AddQueryServices(this IServiceCollection services)
    {
        // 自动扫描注册查询服务（推荐方式）
        RegisterQueriesByConvention(services);
        
        return services;
    }
    
    /// <summary>
    /// 按约定自动注册查询服务
    /// </summary>
    private static void RegisterQueriesByConvention(IServiceCollection services)
    {
        var assembly = Assembly.GetExecutingAssembly();
        
        // 获取所有查询接口和实现类
        var queryTypes = assembly.GetTypes()
            .Where(t => t.IsClass && !t.IsAbstract && t.Name.EndsWith("Queries"))
            .ToList();
            
        foreach (var implementationType in queryTypes)
        {
            // 查找对应的接口
            var interfaceType = implementationType.GetInterfaces()
                .FirstOrDefault(i => i.Name == $"I{implementationType.Name}");
                
            if (interfaceType != null)
            {
                services.AddScoped(interfaceType, implementationType);
            }
        }
    }
}
```

## 使用方式

### 在 ProgramExtensions.cs 中注册

```csharp
public static WebApplicationBuilder ConfigureServices(this WebApplicationBuilder builder)
{
    // 添加数据库服务
    builder.Services.AddCustomDatabase(builder.Configuration);

    // 添加应用层服务（包括查询服务、Mapster配置等）
    builder.Services.AddApplicationServices();

    // 添加 MediatR
    builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Application.Commands.User.CreateUserCommand).Assembly));
    
    // 其他服务...
    
    return builder;
}
```

## 自动注册规则

### 查询服务自动注册

系统会自动扫描并注册符合以下约定的查询服务：

1. **命名约定**：
   - 接口名：`I{ServiceName}Queries`
   - 实现类名：`{ServiceName}Queries`

2. **示例**：
   ```csharp
   // 接口
   public interface IUserQueries { }
   
   // 实现类
   public class UserQueries : IUserQueries { }
   
   // 自动注册为：services.AddScoped<IUserQueries, UserQueries>();
   ```

3. **支持的服务类型**：
   - 所有以 `Queries` 结尾的类
   - 必须有对应的接口
   - 自动注册为 `Scoped` 生命周期

## 添加新的查询服务

### 步骤1：创建接口

```csharp
// Application/Queries/User/IUserStatisticsQueries.cs
namespace Application.Queries.User;

public interface IUserStatisticsQueries
{
    Task<ApiResult<UserStatisticsDto>> GetUserStatisticsAsync();
}
```

### 步骤2：创建实现类

```csharp
// Application/Queries/User/UserStatisticsQueries.cs
namespace Application.Queries.User;

public class UserStatisticsQueries : IUserStatisticsQueries
{
    private readonly ISugarUnitOfWork<DBContext> _unitOfWork;
    private readonly ILogger<UserStatisticsQueries> _logger;

    public UserStatisticsQueries(ISugarUnitOfWork<DBContext> unitOfWork, ILogger<UserStatisticsQueries> logger)
    {
        _unitOfWork = unitOfWork;
        _logger = logger;
    }

    public async Task<ApiResult<UserStatisticsDto>> GetUserStatisticsAsync()
    {
        // 实现逻辑...
    }
}
```

### 步骤3：无需手动注册

由于采用了自动扫描注册，新的查询服务会自动被发现和注册，无需在任何地方手动添加注册代码。

## 验证注册结果

### 构建项目验证

```bash
dotnet build
```

如果构建成功，说明所有服务都已正确注册。

### 运行时验证

在控制器中注入服务来验证：

```csharp
[ApiController]
[Route("api/[controller]")]
public class UserController : ControllerBase
{
    private readonly IUserQueries _userQueries;
    private readonly IUserStatisticsQueries _userStatisticsQueries;

    public UserController(IUserQueries userQueries, IUserStatisticsQueries userStatisticsQueries)
    {
        _userQueries = userQueries;
        _userStatisticsQueries = userStatisticsQueries;
    }
}
```

## 优势

### 1. 统一管理
- 所有应用层服务配置集中在一个地方
- 避免在 `ProgramExtensions.cs` 中逐个注册

### 2. 自动发现
- 新增查询服务无需手动注册
- 减少遗漏注册的风险

### 3. 约定优于配置
- 遵循命名约定即可自动注册
- 代码更加简洁和一致

### 4. 易于维护
- 修改注册逻辑只需在一个地方
- 便于扩展和定制

## 扩展配置

### 添加其他类型的服务

可以在 `ApplicationServiceExtensions.cs` 中添加其他类型的服务注册：

```csharp
public static IServiceCollection AddApplicationServices(this IServiceCollection services)
{
    // 添加查询服务
    services.AddQueryServices();
    
    // 添加其他服务
    services.AddCommandServices();
    services.AddDomainServices();
    
    return services;
}
```

### 自定义注册规则

可以修改 `RegisterQueriesByConvention` 方法来自定义注册规则：

```csharp
private static void RegisterQueriesByConvention(IServiceCollection services)
{
    var assembly = Assembly.GetExecutingAssembly();
    
    // 自定义过滤条件
    var serviceTypes = assembly.GetTypes()
        .Where(t => t.IsClass && !t.IsAbstract)
        .Where(t => t.Name.EndsWith("Queries") || t.Name.EndsWith("Service"))
        .ToList();
        
    // 自定义注册逻辑...
}
```

## 最佳实践

1. **遵循命名约定**：确保接口和实现类名称符合约定
2. **保持单一职责**：每个查询服务只负责特定领域的查询
3. **使用依赖注入**：通过构造函数注入所需的依赖
4. **添加日志记录**：在查询服务中添加适当的日志记录
5. **异常处理**：使用 try-catch 处理异常并返回友好的错误信息
