# 事件驱动系统监控模块使用指南

## 概述

本文档介绍了基于事件总线（MediatR）重构的系统监控模块，包括在线用户管理、登录日志记录和操作日志记录功能。通过事件驱动架构，实现了业务逻辑与监控功能的解耦，提高了系统的可维护性和扩展性。

## 架构设计

### 事件驱动架构
- **事件总线**: 使用 MediatR 作为事件总线实现
- **事件发布**: 在关键业务操作点发布相应事件
- **事件处理**: 通过事件处理器异步处理监控数据记录
- **解耦设计**: 业务逻辑与监控功能完全分离

### 核心组件

#### 1. 事件定义
- `UserLoginEvent`: 用户登录事件
- `UserLogoutEvent`: 用户退出事件  
- `OperationLogEvent`: 操作日志事件

#### 2. 事件处理器
- `UserLoginEventHandler`: 处理用户登录，记录登录日志和在线用户
- `UserLogoutEventHandler`: 处理用户退出，更新在线用户状态
- `OperationLogEventHandler`: 处理操作日志记录

#### 3. 过滤器和属性
- `OperationLogFilter`: ASP.NET Core 动作过滤器，自动拦截标记的控制器动作
- `OperationLogAttribute`: 标记需要记录操作日志的控制器或动作

## 功能模块

### 1. 在线用户管理

#### 功能描述
- 自动记录用户登录状态
- 支持单用户多会话管理
- 自动处理用户下线

#### 实现机制
```csharp
// 用户登录时自动发布事件
await _mediator.Publish(new UserLoginEvent
{
    UserId = user.Id,
    UserName = user.UserName,
    SessionId = refreshToken,
    // ... 其他属性
});
```

#### 数据记录
- 会话ID（使用RefreshToken）
- 用户基本信息
- 登录时间和过期时间
- 客户端信息（IP、浏览器、操作系统）

### 2. 登录日志记录

#### 功能描述
- 记录所有登录尝试（成功和失败）
- 包含详细的客户端信息
- 支持IP地理位置解析

#### 记录内容
- 用户信息
- 登录状态（成功/失败）
- IP地址和地理位置
- 浏览器和操作系统信息
- 登录时间

### 3. 操作日志记录

#### 功能描述
- 自动记录标记的控制器动作
- 记录请求和响应详情
- 支持自定义业务类型和模块

#### 使用方法

##### 控制器级别标记
```csharp
[OperationLog(Module = "系统监控", BusinessType = "监控管理")]
public class MonitorController : ControllerBase
{
    // 所有动作都会被记录
}
```

##### 动作级别标记
```csharp
[OperationLog(BusinessType = "用户管理", Title = "创建用户")]
public async Task<ApiResult<long>> CreateUser([FromBody] CreateUserCommand command)
{
    // 此动作会被记录
}
```

##### 排除特定动作
```csharp
[OperationLog(BusinessType = "用户查询", Exclude = true)]
public async Task<ApiResult<UserDto>> GetUser(long id)
{
    // 此动作不会被记录
}
```

## 配置说明

### 1. 服务注册

MediatR 和相关服务已在 `ProgramExtensions.cs` 中自动注册：

```csharp
// 注册 MediatR
builder.Services.AddMediatR(cfg => 
    cfg.RegisterServicesFromAssembly(typeof(Application.Commands.User.CreateUserCommand).Assembly));

// 注册操作日志过滤器
builder.Services.AddControllers(options =>
{
    options.Filters.Add<Infrastructure.Filters.OperationLogFilter>();
});
```

### 2. 事件处理器

所有事件处理器通过 MediatR 自动发现和注册，无需手动配置。

## 测试验证

### 1. 登录功能测试

#### 测试步骤
1. 调用登录API：`POST /api/auth/signin`
2. 检查登录日志表：`LoginLog`
3. 检查在线用户表：`OnlineUser`

#### 预期结果
- 登录日志记录成功/失败状态
- 在线用户记录当前会话
- 之前的会话状态更新为离线

### 2. 退出功能测试

#### 测试步骤
1. 调用退出API：`POST /api/auth/signout`
2. 检查在线用户表状态更新

#### 预期结果
- 对应会话的在线用户状态更新为离线（Status = 0）

### 3. 操作日志测试

#### 测试步骤
1. 调用标记了 `OperationLogAttribute` 的API
2. 检查操作日志表：`OperationLog`

#### 预期结果
- 记录请求的详细信息
- 包含用户信息、请求参数、响应结果
- 记录执行时间和状态

### 4. 强制下线测试

#### 测试步骤
1. 调用强制下线API：`POST /api/monitor/force-logout/{sessionId}`
2. 检查在线用户状态

#### 预期结果
- 指定会话的用户状态更新为离线
- 发布用户退出事件

## 监控查询

### 1. 在线用户查询
```http
GET /api/monitor/online-users?pageIndex=1&pageSize=10
```

### 2. 登录日志查询
```http
GET /api/monitor/login-logs?pageIndex=1&pageSize=10&userName=test
```

### 3. 操作日志查询
```http
GET /api/monitor/operation-logs?pageIndex=1&pageSize=10&userName=test
```

## 扩展说明

### 1. 添加新的监控事件

#### 步骤
1. 在 `Shared/Events` 目录创建新的事件类
2. 实现 `INotification` 接口
3. 创建对应的事件处理器
4. 在业务逻辑中发布事件

#### 示例
```csharp
// 1. 定义事件
public class UserPasswordChangedEvent : INotification
{
    public long UserId { get; set; }
    public string UserName { get; set; }
    public DateTime ChangeTime { get; set; }
}

// 2. 创建处理器
public class UserPasswordChangedEventHandler : INotificationHandler<UserPasswordChangedEvent>
{
    public async Task Handle(UserPasswordChangedEvent notification, CancellationToken cancellationToken)
    {
        // 记录密码修改日志
    }
}

// 3. 发布事件
await _mediator.Publish(new UserPasswordChangedEvent
{
    UserId = userId,
    UserName = userName,
    ChangeTime = DateTime.Now
});
```

### 2. 自定义操作日志属性

可以扩展 `OperationLogAttribute` 来支持更多自定义选项：

```csharp
[OperationLog(
    BusinessType = "数据导出", 
    Title = "导出用户数据",
    IsSaveRequestData = false,  // 不保存请求数据
    IsSaveResponseData = true   // 保存响应数据
)]
```

## 性能考虑

### 1. 异步处理
- 所有事件处理都是异步的，不会阻塞主业务流程
- 使用 MediatR 的发布订阅模式，支持并发处理

### 2. 数据库优化
- 建议为监控表添加适当的索引
- 定期清理历史数据
- 考虑使用分表策略处理大数据量

### 3. 错误处理
- 事件处理器包含异常捕获和日志记录
- 监控功能异常不会影响主业务流程

## 注意事项

1. **数据一致性**: 事件处理是异步的，可能存在短暂的数据不一致
2. **重复处理**: 确保事件处理器具有幂等性
3. **性能影响**: 大量操作日志可能影响性能，建议合理使用
4. **存储空间**: 监控数据会持续增长，需要定期维护

## 故障排查

### 1. 事件未被处理
- 检查 MediatR 服务是否正确注册
- 确认事件处理器在正确的程序集中
- 查看应用程序日志中的异常信息

### 2. 操作日志未记录
- 确认控制器或动作标记了 `OperationLogAttribute`
- 检查 `OperationLogFilter` 是否正确注册
- 验证用户认证状态

### 3. 在线用户状态异常
- 检查登录/退出事件是否正确发布
- 确认会话ID（RefreshToken）的一致性
- 查看事件处理器的执行日志

通过以上指南，你可以有效地使用和维护基于事件驱动的系统监控模块。如有问题，请查看相关日志或联系开发团队。
