# 依赖注入重构总结

## 重构背景

原来的依赖注入配置方式是在 `ProgramExtensions.cs` 中逐个注册查询服务：

```csharp
// 原来的方式 - 不推荐
builder.Services.AddScoped<Application.Queries.User.IUserQueries, Application.Queries.User.UserQueries>();
```

这种方式存在以下问题：
- 每次添加新的查询服务都需要手动注册
- 容易遗漏注册导致运行时错误
- `ProgramExtensions.cs` 文件会变得越来越臃肿
- 不符合开闭原则

## 重构方案

### 1. 创建统一的服务扩展类

创建了 `Application/DependencyInjection/ApplicationServiceExtensions.cs`：

```csharp
public static class ApplicationServiceExtensions
{
    /// <summary>
    /// 添加应用层服务
    /// </summary>
    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        // 添加查询服务
        services.AddQueryServices();
        
        return services;
    }
    
    /// <summary>
    /// 添加查询服务
    /// </summary>
    private static IServiceCollection AddQueryServices(this IServiceCollection services)
    {
        // 自动扫描注册查询服务（推荐方式）
        RegisterQueriesByConvention(services);
        
        return services;
    }
}
```

### 2. 实现自动扫描注册

通过反射自动发现和注册符合命名约定的查询服务：

```csharp
/// <summary>
/// 按约定自动注册查询服务
/// </summary>
private static void RegisterQueriesByConvention(IServiceCollection services)
{
    var assembly = Assembly.GetExecutingAssembly();
    
    // 获取所有查询接口和实现类
    var queryTypes = assembly.GetTypes()
        .Where(t => t.IsClass && !t.IsAbstract && t.Name.EndsWith("Queries"))
        .ToList();
        
    foreach (var implementationType in queryTypes)
    {
        // 查找对应的接口
        var interfaceType = implementationType.GetInterfaces()
            .FirstOrDefault(i => i.Name == $"I{implementationType.Name}");
            
        if (interfaceType != null)
        {
            services.AddScoped(interfaceType, implementationType);
        }
    }
}
```

### 3. 更新 ProgramExtensions.cs

简化了 `ProgramExtensions.cs` 中的服务注册：

```csharp
// 修改前
builder.Services.AddScoped<Application.Queries.User.IUserQueries, Application.Queries.User.UserQueries>();

// 修改后
builder.Services.AddApplicationServices();
```

## 实现效果

### 1. 自动注册验证

创建了示例查询服务来验证自动注册功能：

- `IUserStatisticsQueries` 接口
- `UserStatisticsQueries` 实现类
- 相关的 DTO 类

### 2. 构建验证

✅ 项目构建成功，所有服务都被正确注册

### 3. 命名约定

系统会自动注册符合以下约定的服务：
- 接口名：`I{ServiceName}Queries`
- 实现类名：`{ServiceName}Queries`
- 生命周期：`Scoped`

## 文件结构

```
Application/
├── DependencyInjection/
│   ├── ApplicationServiceExtensions.cs    # 应用层服务扩展（新增）
│   └── MapsterConfiguration.cs           # Mapster 配置
├── Queries/
│   └── User/
│       ├── IUserQueries.cs               # 原有接口
│       ├── UserQueries.cs                # 原有实现
│       ├── IUserStatisticsQueries.cs     # 新增接口（示例）
│       └── UserStatisticsQueries.cs      # 新增实现（示例）
└── ...
```

## 优势对比

| 方面 | 原来的方式 | 重构后的方式 |
|------|------------|--------------|
| **注册方式** | 手动逐个注册 | 自动扫描注册 |
| **维护成本** | 高（每次都要手动添加） | 低（遵循约定即可） |
| **出错风险** | 高（容易遗漏注册） | 低（自动发现） |
| **代码整洁** | 差（ProgramExtensions 臃肿） | 好（统一管理） |
| **扩展性** | 差（违反开闭原则） | 好（符合开闭原则） |

## 使用示例

### 添加新的查询服务

1. **创建接口**：
```csharp
public interface IOrderQueries
{
    Task<ApiResult<List<OrderDto>>> GetOrdersAsync();
}
```

2. **创建实现类**：
```csharp
public class OrderQueries : IOrderQueries
{
    // 实现逻辑...
}
```

3. **无需手动注册** - 系统会自动发现并注册

### 在控制器中使用

```csharp
[ApiController]
public class OrderController : ControllerBase
{
    private readonly IOrderQueries _orderQueries;

    public OrderController(IOrderQueries orderQueries)
    {
        _orderQueries = orderQueries; // 自动注入
    }
}
```

## 扩展性

### 支持其他类型的服务

可以轻松扩展支持其他类型的服务：

```csharp
public static IServiceCollection AddApplicationServices(this IServiceCollection services)
{
    // 添加查询服务
    services.AddQueryServices();
    
    // 添加命令服务
    services.AddCommandServices();
    
    // 添加领域服务
    services.AddDomainServices();
    
    return services;
}
```

### 自定义注册规则

可以根据需要自定义注册规则：

```csharp
private static void RegisterServicesByConvention(IServiceCollection services, string suffix, ServiceLifetime lifetime = ServiceLifetime.Scoped)
{
    var assembly = Assembly.GetExecutingAssembly();
    
    var serviceTypes = assembly.GetTypes()
        .Where(t => t.IsClass && !t.IsAbstract && t.Name.EndsWith(suffix))
        .ToList();
        
    foreach (var implementationType in serviceTypes)
    {
        var interfaceType = implementationType.GetInterfaces()
            .FirstOrDefault(i => i.Name == $"I{implementationType.Name}");
            
        if (interfaceType != null)
        {
            services.Add(new ServiceDescriptor(interfaceType, implementationType, lifetime));
        }
    }
}
```

## 最佳实践

1. **遵循命名约定**：确保接口和实现类名称符合约定
2. **保持单一职责**：每个服务只负责特定的功能
3. **统一生命周期**：同类型的服务使用相同的生命周期
4. **文档维护**：及时更新相关文档
5. **测试验证**：添加新服务后进行构建和运行测试

## 总结

通过这次重构，我们实现了：

✅ **统一管理**：所有应用层服务配置集中管理  
✅ **自动注册**：新增服务无需手动注册  
✅ **约定优于配置**：遵循命名约定即可  
✅ **易于维护**：减少了维护成本和出错风险  
✅ **良好扩展性**：支持多种类型的服务注册  

这种方式参考了 YseTTSAPIService 项目的设计思想，但适配了 KiteServer 项目使用原生 DI 容器的特点，既保持了代码的简洁性，又提供了良好的扩展性。
